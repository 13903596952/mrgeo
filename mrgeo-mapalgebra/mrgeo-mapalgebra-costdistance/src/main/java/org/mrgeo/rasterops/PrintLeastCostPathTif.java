package org.mrgeo.rasterops;

import org.mrgeo.image.MrsImage;
import org.mrgeo.image.MrsImagePyramid;
import org.mrgeo.utils.TMSUtils;
import org.mrgeo.utils.TMSUtils.Bounds;

import java.awt.image.Raster;
import java.io.IOException;
import java.util.Properties;

/**
 * This is a utility to view cost surfaces generated by GenerateLeastCostPathTif
 * 
 * The paths are hard-coded in there for now
 */
public class PrintLeastCostPathTif
{
  public static void main(String args[]) throws IOException {
    String leastCostPathPyramidStr = "/mrgeo/images/leastCostPath";
    MrsImagePyramid leastCostPathPyramid  = MrsImagePyramid.open(leastCostPathPyramidStr,
        (Properties)null);
    MrsImage leastCostPathImage = leastCostPathPyramid.getHighestResImage();
    
    int zoomLevel = leastCostPathImage.getZoomlevel();
    int tileSize = leastCostPathImage.getTilesize();
    for(long ty = leastCostPathImage.getMinTileY(); ty <= leastCostPathImage.getMaxTileY(); ty++) {
      for(long tx = leastCostPathImage.getMinTileX(); tx <= leastCostPathImage.getMaxTileX(); tx++) {
        Raster r = leastCostPathImage.getTile(tx, ty);
        long tileId = TMSUtils.tileid(tx, ty, zoomLevel);

        if(containsPath(r)) {
          System.out.println(String.format("tile %d with tx %d ty %d contains path", tileId, tx, ty));
          printIfContainsStartOrEndPoint(r, tx, ty, zoomLevel, tileSize);
        }
      }      
    }
  }
  
  public static boolean containsPath(Raster r) {
    
    for(int py = 0; py < r.getHeight(); py++) {
      for(int px = 0; px < r.getWidth(); px++) {
        float f = r.getSampleFloat(px, py, 0);
        if(!Float.isNaN(f) && (f > 1 || f == 0)) {
           return true;
        }
      }     
    }
    return false;
  }
  
  public static void printIfContainsStartOrEndPoint(Raster r, long tx, long ty, int zoomLevel, int tileSize) {
    long tileId = TMSUtils.tileid(tx, ty, zoomLevel);

    Bounds tileBounds = TMSUtils.tileBounds(tx, ty, zoomLevel, tileSize);
    double resolution = TMSUtils.resolution(zoomLevel, tileSize);
    
    for(int py = 0; py < r.getHeight(); py++) {
      for(int px = 0; px < r.getWidth(); px++) {
        float f = r.getSampleFloat(px, py, 0);
        if(f == 0f || f == 50000f) {
          
          double lat = tileBounds.n - (py * resolution);
          double lon = tileBounds.w + (px * resolution);
          
          if(f == 50000f) {
            System.out.println(String.format("\ttile %d with tx %d ty %d contains end point with lat %f lon %f", tileId, tx, ty, lat, lon));          
          } else if(f == 0f) {
            System.out.println(String.format("\ttile %d with tx %d ty %d contains start point with lat %f lon %f", tileId, tx, ty, lat, lon));                     
          }
        }
      }     
    }
  }
}
