package org.mrgeo.rasterops;

import org.mrgeo.progress.Progress;
import org.mrgeo.progress.ProgressHierarchy;
import org.mrgeo.utils.Bounds;
import org.mrgeo.utils.TMSUtils;

import java.io.IOException;
import java.text.MessageFormat;
import java.util.Comparator;
import java.util.Set;

/**
 * Provides capabilities for extracting random sample pixels from
 * raster inputs.
 */
public class RandomSampler
{
  private static final double AOI_COVERAGE = 0.2;
  private static final double EXCLUSION_PERCENTAGE_THRESHOLD = 0.6;
  private static final int MIN_NUM_POINTS = 100000;

  /**
   * RandomSampler reports each of the points it generates to an object that
   * implements this interface.
   */
  public interface RandomSamplerListener
  {
    /**
     * The RandomSampler calls this method immediately before generating
     * and reporting random points.
     */
    public void beginningSamples() throws IOException;

    /**
     * The RandomSampler calls this method after all points have been
     * generated. This method is guaranteed to be called after processing
     * random points.
     */
    public void completedSamples() throws IOException;

    /**
     * Each time a random point is generated by RandomSampler, it invokes
     * this method with the world pixel and the world location, based on the
     * zoom level and tileSize that the RandomSampler was invoked with.
     * 
     * @param pixel
     * @param location
     */
    public void reportPoint(TMSUtils.Pixel pixel, TMSUtils.LatLon location)
        throws IOException;
  }

  /**
   * An iterator class for returning all pixels within a pixel grid, skipping
   * any pixels in an optional set of exclusions.
   */
  public static class AllPixelIterator implements java.util.Iterator<TMSUtils.Pixel>
  {
    private long px;
    private long py;
    private TMSUtils.Pixel topLeft;
    private TMSUtils.Pixel bottomRight;
    private Set<TMSUtils.Pixel> exclusions;
    private TMSUtils.Pixel currPixel;

    public AllPixelIterator(TMSUtils.Pixel topLeft, TMSUtils.Pixel bottomRight)
    {
      this(topLeft, bottomRight, null);
    }

    public AllPixelIterator(TMSUtils.Pixel topLeft, TMSUtils.Pixel bottomRight,
        Set<TMSUtils.Pixel> exclusions)
    {
      this.px = topLeft.px - 1;
      this.py = topLeft.py;
      this.topLeft = topLeft;
      this.bottomRight = bottomRight;
      this.exclusions = exclusions;
      gotoNextPixel();
    }

    private boolean gotoNextPixel()
    {
      // Check to see if we're already at the end
      if (py > bottomRight.py)
      {
        return false;
      }

      // Need a while loop to scan past exclusions
      while (true)
      {
        // Increment the pixel coordinate(s) - left to right, top to bottom
        px++;
        if (px > bottomRight.px)
        {
          px = topLeft.px;
          py++;
        }
        if (py <= bottomRight.py)
        {
          // We have not gotten to the end yet.
          // If there are no exclusions or the current pixel is not in
          // the exclusion set, then return the pixel. Otherwise move
          // to the next pixel.
          TMSUtils.Pixel pixel = new TMSUtils.Pixel(px, py);
          if (exclusions == null || !exclusions.contains(pixel))
          {
            // Found the next point
            currPixel = pixel;
            break;
          }
        }
        else
        {
          // We have iterated through the end
          currPixel = null;
          break;
        }
      }
      return (currPixel != null);
    }

    @Override
    public boolean hasNext()
    {
      return (currPixel != null);
    }

    @Override
    public TMSUtils.Pixel next()
    {
      TMSUtils.Pixel result = currPixel;
      gotoNextPixel();
      return result;
      /*
      while (hasNext())
      {
        TMSUtils.Pixel pixel = new TMSUtils.Pixel(px, py);
        px++;
        if (px > bottomRight.px)
        {
          px = topLeft.px;
          py++;
        }
        // If there are no exclusions or the current pixel is not in
        // the exclusion set, then return the pixel. Otherwise move
        // to the next pixel.
        if (exclusions == null || !exclusions.contains(pixel))
        {
          return pixel;
        }
      }
      return null;
      */
    }

    @Override
    public void remove()
    {
      // Intentionally not implemented
    }
  }

  public class PixelComparator implements Comparator<TMSUtils.Pixel>
  {
    @Override
    public int compare(TMSUtils.Pixel p1, TMSUtils.Pixel p2)
    {
      if (p1.px == p2.px) {
        if (p1.py == p2.py) {
          return 0;
        }
        else if (p1.py < p2.py) {
          return -1;
        }
        return 1;
      }
      else if (p1.px < p2.px) {
        return -1;
      }
      return 1;
    }
  }

  public void generateRandomPoints(Progress p, Bounds bounds, int zoomLevel, int tileSize,
      long sampleCount, RandomSamplerListener listener)
          throws IOException, IllegalArgumentException
  {
    ProgressHierarchy ph = new ProgressHierarchy(p);
    ph.createChild(1.0f);
    ph.createChild(1.0f);
    
    TMSUtils.Pixel pxTopLeft = TMSUtils.latLonToPixelsUL(bounds.getMaxY(), bounds.getMinX(), zoomLevel, tileSize);
    TMSUtils.Pixel pxBottomRight = TMSUtils.latLonToPixelsUL(bounds.getMinY(), bounds.getMaxX(), zoomLevel, tileSize);
    long height = pxBottomRight.py - pxTopLeft.py + 1;
    long width = pxBottomRight.px - pxTopLeft.px + 1;

    // Check for reasonable sampleCount value
    if (sampleCount > 0)
    {
      long samples = sampleCount;
      if (samples > height * width)
      {
        throw new IllegalArgumentException(
            MessageFormat.format("RandomSampler cannot generate more sample points ({0}) than what is available in the input raster ({1}).",
                samples, (height * width)));
      }
    }
    boolean useAllPixels = false;
    boolean exclusions = false;
    long totalPixels = height * width;
    // Auto-calculate the sampleCount if needed
    if (sampleCount <= 0)
    {
      if (totalPixels <= MIN_NUM_POINTS)
      {
        useAllPixels = true;
      }
      else
      {
        sampleCount = (long)(totalPixels * AOI_COVERAGE);
        if (sampleCount < MIN_NUM_POINTS)
        {
          sampleCount = MIN_NUM_POINTS;
        }
      }
    }

    java.util.TreeSet<TMSUtils.Pixel> randomPixels; // to keep in scope while writing pixels
    java.util.Iterator<TMSUtils.Pixel> pixelIter = null;
    float stepPercentage = 1.0F / sampleCount;
    if (useAllPixels)
    {
      pixelIter = new AllPixelIterator(pxTopLeft, pxBottomRight);
    }
    else
    {
      long randomCount = sampleCount;
      // If the number of pixels to generate randomly is more than about
      // 60% of the total number of pixels available, it will be faster
      // to generate the points to excluded from the full set of pixels
      // available (e.g. 40% of the total or less).
      if (randomCount > (totalPixels * EXCLUSION_PERCENTAGE_THRESHOLD))
      {
        randomCount = totalPixels - sampleCount;
        exclusions = true;
      }
  
      Comparator<TMSUtils.Pixel> pixelComparator = new PixelComparator();
      randomPixels = new java.util.TreeSet<TMSUtils.Pixel>(pixelComparator);
      float lastPercent = 0.0F;
      // Generate the set of random points, regardless of whether they are being
      // used as exclusions or not.
      java.util.Random r = new java.util.Random();
      for (long ii=0; ii < randomCount; ii++)
      {
        // Make sure we don't grab the same pixel more than once
        boolean added = false;
        while (!added)
        {
          long px = pxTopLeft.px + (long)(r.nextDouble() * width);
          long py = pxTopLeft.py + (long)(r.nextDouble() * height);
          TMSUtils.Pixel pixel = new TMSUtils.Pixel(px, py);
          if (!randomPixels.contains(pixel))
          {
            randomPixels.add(pixel);
            added = true;
          }
        }
        // Update the percent complete when it increases by at least 1 percent
        float currPercentComplete = ((ii + 1) * stepPercentage * 100.0F);
        if (currPercentComplete > 100.0)
        {
          currPercentComplete = 100.0F;
        }
        if (currPercentComplete - lastPercent >= 1.0)
        {
          ph.getChild(0).set(currPercentComplete);
          lastPercent = currPercentComplete;
        }
      }
      if (exclusions)
      {
        pixelIter = new AllPixelIterator(pxTopLeft, pxBottomRight, randomPixels);
      }
      else
      {
        pixelIter = randomPixels.iterator();
      }
    }
    ph.getChild(0).complete();
    
    listener.beginningSamples();
    try
    {
      float lastPercent = 0.0F;
      int iterCount = 0;
      while (pixelIter.hasNext()) {
        TMSUtils.Pixel pixel = pixelIter.next();
        TMSUtils.LatLon loc = TMSUtils.pixelToLatLonUL(pixel.px,
            pixel.py, zoomLevel, tileSize);
        listener.reportPoint(pixel, loc);

        // Update the percent complete when it increases by at least 1 percent
        float currPercentComplete = ((iterCount + 1) * stepPercentage * 100.0F);
        if (currPercentComplete > 100.0) {
          currPercentComplete = 100.0F;
        }
        if (currPercentComplete - lastPercent >= 1.0) {
          ph.getChild(1).set(currPercentComplete);
          lastPercent = currPercentComplete;
        }
        iterCount++;
      }
      ph.getChild(1).complete();
    }
//    catch(InterruptedException e) {
//      // Nothing to do here b/c this operation is not threaded, and map/reduce is not used
//    }
    finally
    {
      listener.completedSamples();
    }
  }
}
